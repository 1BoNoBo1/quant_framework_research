---
name: quant-sparc-specialist
type: methodology
description: Agent SPARC spÃ©cialisÃ© pour le dÃ©veloppement de stratÃ©gies quantitatives et de trading
version: 1.0.0

# Configuration SPARC pour finance quantitative
sparc_config:
  specification:
    format: "quantitative_research"
    detail_level: "comprehensive"
    include_mathematical_proofs: true
    include_backtesting_plan: true

  pseudocode:
    style: "financial-python"
    include_vectorization: true
    include_risk_calculations: true
    docstrings: "quant_style"

  architecture:
    patterns: ["Hexagonal", "Strategy Pattern", "Repository", "Observer", "Factory"]
    frameworks: ["QFrame", "MLflow", "PyTorch", "CCXT", "TA-Lib"]
    databases: ["PostgreSQL", "Redis", "TimescaleDB"]

  refinement:
    iterations: 5
    validation_steps: true
    performance_optimization: true
    risk_validation: true

  completion:
    backtesting_required: true
    documentation_required: true
    monitoring_setup: true
    production_readiness: true

# CapacitÃ©s spÃ©cialisÃ©es en finance quantitative
capabilities:
  specification_phase:
    - "Analyse des objectifs de trading"
    - "ModÃ©lisation mathÃ©matique des stratÃ©gies"
    - "SpÃ©cification des mÃ©triques de performance"
    - "DÃ©finition des contraintes de risque"
    - "Planification des donnÃ©es historiques"
    - "Architecture des pipelines ML"

  pseudocode_phase:
    - "Algorithmes de trading vectorisÃ©s"
    - "Formules alpha avec opÃ©rateurs symboliques"
    - "Logique de gestion des risques"
    - "Pipelines de feature engineering"
    - "ModÃ¨les ML pour finance"

  architecture_phase:
    - "Architecture hexagonale pour trading"
    - "Patterns d'intÃ©gration exchange"
    - "Design de backtesting framework"
    - "SystÃ¨mes de monitoring temps rÃ©el"
    - "Pipeline MLOps pour finance"

  refinement_phase:
    - "Optimisation des performances NumPy"
    - "RÃ©duction de la latence"
    - "AmÃ©lioration des mÃ©triques de trading"
    - "Gestion avancÃ©e des risques"
    - "Validation croisÃ©e temporelle"

  completion_phase:
    - "Backtesting complet avec mÃ©triques"
    - "Tests de stress et Monte Carlo"
    - "Documentation de stratÃ©gie"
    - "Configuration production"
    - "Monitoring et alertes"

# Templates SPARC pour stratÃ©gies quantitatives
templates:
  strategy_specification:
    content: |
      # SpÃ©cification de StratÃ©gie: {strategy_name}

      ## ğŸ“Š HypothÃ¨se de Trading
      **Alpha Source**: {alpha_hypothesis}
      **Market Inefficiency**: {market_inefficiency}
      **Time Horizon**: {time_horizon}
      **Universe**: {trading_universe}

      ## ğŸ¯ Objectifs Quantitatifs
      - **Sharpe Ratio Target**: {target_sharpe}
      - **Maximum Drawdown**: < {max_drawdown}%
      - **Win Rate**: > {min_win_rate}%
      - **Information Coefficient**: > {min_ic}

      ## ğŸ§® ModÃ©lisation MathÃ©matique
      ### Signal Generation
      ```
      Signal(t) = f(Features(t), Parameters)
      where Features(t) = [Price, Volume, Technical, Fundamental, Alternative]
      ```

      ### Position Sizing
      ```
      Position(t) = Signal(t) * RiskBudget(t) * VolatilityAdjustment(t)
      ```

      ### Risk Constraints
      - **Portfolio VaR**: < {var_limit}%
      - **Single Asset Weight**: < {max_weight}%
      - **Sector Exposure**: < {sector_limit}%

      ## ğŸ“ˆ Features & Data
      ### Primary Features
      {primary_features}

      ### Derived Features (Symbolic Operators)
      {symbolic_features}

      ### External Data
      {external_data}

      ## ğŸ”„ Pipeline Architecture
      1. **Data Ingestion**: {data_sources}
      2. **Feature Engineering**: {feature_pipeline}
      3. **Signal Generation**: {signal_logic}
      4. **Risk Management**: {risk_system}
      5. **Execution**: {execution_system}

  strategy_pseudocode:
    content: |
      # Pseudocode: {strategy_name}

      ```python
      from typing import Dict, List, Tuple, Optional
      import numpy as np
      import pandas as pd
      from qframe.core.interfaces import IStrategy, IDataProvider, IRiskManager

      class {StrategyClass}(IStrategy):
          """
          {strategy_description}

          Mathematical Model:
          {mathematical_model}

          Expected Performance:
          - Sharpe Ratio: {expected_sharpe}
          - Max Drawdown: {expected_drawdown}%
          """

          def __init__(
              self,
              data_provider: IDataProvider,
              risk_manager: IRiskManager,
              params: {StrategyClass}Config
          ):
              self.data_provider = data_provider
              self.risk_manager = risk_manager
              self.params = params
              self._initialize_models()

          def _initialize_models(self) -> None:
              """Initialize ML models and technical indicators."""
              # Step 1: Initialize feature processors
              self.feature_processor = self._setup_feature_processor()

              # Step 2: Load/Initialize ML models
              self.ml_models = self._setup_ml_models()

              # Step 3: Setup technical indicators
              self.technical_indicators = self._setup_technical_indicators()

          def generate_signals(
              self,
              market_data: pd.DataFrame
          ) -> pd.DataFrame:
              """
              Generate trading signals based on market data.

              Args:
                  market_data: OHLCV data with columns [open, high, low, close, volume]

              Returns:
                  DataFrame with columns [timestamp, symbol, signal, confidence]
              """
              # Step 1: Feature Engineering
              features = self._engineer_features(market_data)

              # Step 2: Generate Alpha Scores
              alpha_scores = self._calculate_alpha_scores(features)

              # Step 3: Apply Risk Filters
              filtered_signals = self._apply_risk_filters(alpha_scores)

              # Step 4: Position Sizing
              sized_positions = self._calculate_position_sizes(filtered_signals)

              return sized_positions

          def _engineer_features(self, data: pd.DataFrame) -> pd.DataFrame:
              """Create sophisticated features using symbolic operators."""
              # Technical features
              {technical_features_logic}

              # ML-derived features
              {ml_features_logic}

              # Risk-adjusted features
              {risk_features_logic}

              return combined_features

          def _calculate_alpha_scores(self, features: pd.DataFrame) -> pd.DataFrame:
              """Calculate alpha scores using ensemble models."""
              # Primary model prediction
              {primary_model_logic}

              # Secondary model validation
              {secondary_model_logic}

              # Ensemble combination
              {ensemble_logic}

              return alpha_scores

          def backtest(
              self,
              start_date: str,
              end_date: str,
              initial_capital: float = 100000
          ) -> Dict[str, float]:
              """
              Comprehensive backtesting with performance metrics.

              Returns:
                  Performance metrics dictionary
              """
              # Step 1: Load historical data
              historical_data = self._load_backtest_data(start_date, end_date)

              # Step 2: Generate signals
              signals = self.generate_signals(historical_data)

              # Step 3: Simulate trading
              portfolio_returns = self._simulate_trading(signals, historical_data)

              # Step 4: Calculate metrics
              metrics = self._calculate_performance_metrics(portfolio_returns)

              return metrics
      ```

  architecture_design:
    content: |
      # Architecture: {strategy_name} dans QFrame

      ## ğŸ—ï¸ Vue d'ensemble Architecture Hexagonale

      ```
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                    Application Core                          â”‚
      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
      â”‚  â”‚              {StrategyClass}                        â”‚   â”‚
      â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
      â”‚  â”‚  â”‚            Domain Logic                     â”‚   â”‚   â”‚
      â”‚  â”‚  â”‚  â€¢ Signal Generation                        â”‚   â”‚   â”‚
      â”‚  â”‚  â”‚  â€¢ Risk Management                          â”‚   â”‚   â”‚
      â”‚  â”‚  â”‚  â€¢ Position Sizing                          â”‚   â”‚   â”‚
      â”‚  â”‚  â”‚  â€¢ Performance Tracking                     â”‚   â”‚   â”‚
      â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                  Ports & Adapters                             â”‚
      â”‚                                                                â”‚
      â”‚  Input Ports:          â”‚              Output Ports:           â”‚
      â”‚  â€¢ IDataProvider       â”‚              â€¢ IOrderManager         â”‚
      â”‚  â€¢ IRiskManager        â”‚              â€¢ IPortfolioManager     â”‚
      â”‚  â€¢ IFeatureProcessor   â”‚              â€¢ IMetricsCollector     â”‚
      â”‚  â€¢ IMLModelProvider    â”‚              â€¢ IAlertManager         â”‚
      â”‚                                                                â”‚
      â”‚  Adapters:                                                     â”‚
      â”‚  â€¢ CCXTDataAdapter     â”‚              â€¢ BinanceOrderAdapter   â”‚
      â”‚  â€¢ RedisRiskAdapter    â”‚              â€¢ MLflowMetricsAdapter  â”‚
      â”‚  â€¢ PostgreSQLAdapter   â”‚              â€¢ SlackAlertAdapter     â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      ```

      ## ğŸ“Š Flux de DonnÃ©es

      ### 1. Data Pipeline
      ```
      Market Data â†’ Feature Engineering â†’ ML Models â†’ Signals â†’ Risk Filters â†’ Orders
      ```

      ### 2. Components DÃ©taillÃ©s

      #### Core Strategy
      ```python
      class {StrategyClass}:
          # Domain logic pure
          # Pas de dÃ©pendances externes
          # Tests unitaires simples
      ```

      #### Data Layer
      ```python
      class MarketDataRepository:
          # Gestion des donnÃ©es OHLCV
          # Cache Redis pour performance
          # Validation des donnÃ©es
      ```

      #### ML Layer
      ```python
      class MLModelService:
          # Gestion des modÃ¨les PyTorch
          # Feature store
          # Model versioning avec MLflow
      ```

      #### Risk Layer
      ```python
      class RiskManagementService:
          # Calculs VaR temps rÃ©el
          # Position limits
          # Stress testing
      ```

      ## ğŸ”„ Patterns UtilisÃ©s

      ### 1. Strategy Pattern
      - Multiple stratÃ©gies interchangeables
      - Configuration par injection

      ### 2. Repository Pattern
      - Abstraction des sources de donnÃ©es
      - TestabilitÃ© amÃ©liorÃ©e

      ### 3. Observer Pattern
      - Notifications temps rÃ©el
      - Monitoring dÃ©centralisÃ©

      ### 4. Factory Pattern
      - CrÃ©ation de stratÃ©gies configurables
      - Support multi-exchange

      ## ğŸš€ Performance & ScalabilitÃ©

      ### Optimisations
      - **Vectorisation NumPy**: Calculs batch
      - **Cache Redis**: Features prÃ©-calculÃ©es
      - **Async Processing**: I/O non-bloquant
      - **Parallel Computing**: Multi-threading

      ### MÃ©triques Cibles
      - **Latency**: < 50ms signal generation
      - **Throughput**: > 1000 symbols/second
      - **Memory**: < 4GB per strategy
      - **CPU**: < 80% utilization

# Workflows SPARC spÃ©cialisÃ©s
workflows:
  quantitative_strategy_sparc:
    name: "Cycle SPARC StratÃ©gie Quantitative"
    steps:
      - phase: "Specification"
        tasks:
          - "DÃ©finir l'hypothÃ¨se de trading"
          - "ModÃ©liser mathÃ©matiquement la stratÃ©gie"
          - "SpÃ©cifier les mÃ©triques cibles"
          - "Identifier les sources de donnÃ©es"

      - phase: "Pseudocode"
        tasks:
          - "Ã‰crire les algorithmes de signal"
          - "DÃ©finir le pipeline de features"
          - "SpÃ©cifier la gestion des risques"
          - "Documenter les modÃ¨les ML"

      - phase: "Architecture"
        tasks:
          - "Concevoir l'architecture hexagonale"
          - "DÃ©finir les interfaces et adapters"
          - "Planifier l'intÃ©gration MLOps"
          - "Structurer le backtesting framework"

      - phase: "Refinement"
        tasks:
          - "Optimiser les performances NumPy"
          - "AmÃ©liorer les mÃ©triques de trading"
          - "Valider les modÃ¨les ML"
          - "Affiner la gestion des risques"

      - phase: "Completion"
        tasks:
          - "Backtesting complet"
          - "Tests de stress"
          - "Documentation complÃ¨te"
          - "Configuration production"

# MÃ©triques spÃ©cifiques au trading
performance_metrics:
  trading_metrics:
    - sharpe_ratio: "> 1.5"
    - sortino_ratio: "> 2.0"
    - max_drawdown: "< 15%"
    - win_rate: "> 55%"
    - profit_factor: "> 1.3"

  ml_metrics:
    - information_coefficient: "> 0.05"
    - rank_ic: "> 0.07"
    - hit_rate: "> 0.52"
    - alpha_decay: "< 10 days"

  system_metrics:
    - signal_latency: "< 50ms"
    - backtest_speed: "> 100x realtime"
    - memory_usage: "< 4GB"
    - cpu_utilization: "< 80%"